# 1. 运行时权限
> 权限分为普通权限和危险权限，普通权限只需要在 AndroidManifest.xml 中声明即可，危险权限 **不但要声明，还需要手动实现运行时权限处理**

```java
Intent intent = new Intent(Intent.ACTION_CALL);
intent.setData(Uri.parse("tel:110"));
```
> Intent.ACTION_CALL　是拨打号码，危险权限,需要进行运行时权限处理
  Intent.ACTION_DIAL  是打开拨号界面，普通权限


> 1. 先判断是否授予权限，如果没有授予权限，申请授予（弹出对话框）

```java

if (ContextCompat.checkSelfPermission(mContext, Manifest.permission.CALL_PHONE) != PackageManager.PERMISSION_GRANTED) {
    //  如果所需要的权限没有被授权, 请求授权
    ActivityCompat.requestPermissions(MainActivity.this, new String[]{Manifest.permission.CALL_PHONE}, 1);  // 指定该请求的请求码
} else {
    //如果被授权，直接执行打电话
    call();
}
```

> 2. 在Activity重写 `onRequestPermissionsResult`方法，当弹出对话框，用户点击选择结果的时候，该方法回调

```java
public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) {
    switch (requestCode) {
        case 1:
            if (grantResults.length > 0 && grantResults[0] == PackageManager.PERMISSION_GRANTED) {
                // 用户确认授予权限
                call();
            } else {
            	// 用户拒绝
                Toast.makeText(mContext, "You denied the permission...", Toast.LENGTH_SHORT).show();
            }
            break;
        default:
            break;
    }
}

```

> 当用户授予之后，下次再进行该操作，就默认用户授予该权限，不会弹出对话框再让用户选择了


# 2. 内容提供器访问其他程序中的数据
> 内容提供器用法:
>  	1. 使用现有的内容提供器来读取和操作响应程序中的数据，例如，获取联系人信息
>	2. 创建自己的应用程序的内容提供器，为自己程序的数据外部访问提供接口

## 访问已有的内容提供器中的数据
1. getContentReceiver() 获取 ContentResolver 对象
2. 调用 ContentResolver 对象的 CURD方法 (delete/update/query/insert)，和SQLiteDatabase 对象的方法相似
3. 不过，参数中包含 Uri 对象, 由内容URI字符串解析所得
	Uri对象的作用： 帮助ContentResolver对象 找到目标内容提供器和目标表

	内容URI字符串组成
	- 协议 content://
	- authority: 一般用程序的包名表示
	- path:  程序数据库中的表名

	例：包名为 com.example.ethanwalker.app ，其中一个表名为 table1, 协议为 content
		故 标准的 URI 写法: content://com.example.ethanwalker.app/table1
			可能还有在后面加上标识符id : content://com.example.ethanwalker.app/table1/1 （获取table1中id=1的元组）

	将其解析成 Uri对象: Uri.parse("content://com.example.ethanwalker.app/table1");

4. query 方法参数:
	uri: 指定目标程序以及目标表
	projection: 指定查询的列名 （相当于 SQLiteDatabase query 中的 columns 参数）
	selection:  where的约束条件
	selectionArgs:  约束条件中的参数
	orderBy:  排序

5. 调用下述方法，传入Uri对象
	getContentReceiver().insert()  返回新插入行的Uri对象，多了新插入行的id
 					   .delete()
					   .update()
					   .query() 返回Cursor对象

	调用这些方法，然后系统又会回调目标内容提供器对应的方法(insert、query、delete、update)

实例：读取联系人

```java
public class MainActivity extends AppCompatActivity {
    private static final String TAG = "MainActivity";

    ArrayAdapter<String> adapter;
    List<String> contactsList = new ArrayList<>();

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        ListView contactsView = (ListView) findViewById(R.id.contacts_list);
        adapter = new ArrayAdapter<String>(this, android.R.layout.simple_list_item_1, contactsList);
        contactsView.setAdapter(adapter);

        if (ContextCompat.checkSelfPermission(this, Manifest.permission.READ_CONTACTS) != PackageManager.PERMISSION_GRANTED) {
            ActivityCompat.requestPermissions(this, new String[]{Manifest.permission.READ_CONTACTS}, 1);
        } else {
            readContacts();
        }
    }

    @Override
    public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) {
        switch (requestCode) {
            case 1:
                if (grantResults.length > 0 && grantResults[0] == PackageManager.PERMISSION_GRANTED) {
                    readContacts();
                } else {
                    Toast.makeText(this, "you denied to read the contacts", Toast.LENGTH_SHORT).show();
                }
                break;
            default:
                break;
        }
    }

    public void readContacts() {
        Cursor cursor = null;
        try {
            cursor = getContentResolver().query(ContactsContract.CommonDataKinds.Phone.CONTENT_URI, null, null, null, null);
            if (cursor != null) {
                while (cursor.moveToNext()) {
                    String name = cursor.getString(cursor.getColumnIndex(ContactsContract.CommonDataKinds.Phone.DISPLAY_NAME));
                    String number = cursor.getString(cursor.getColumnIndex(ContactsContract.CommonDataKinds.Phone.NUMBER));
                    contactsList.add(name + "\n" + number);
                }
            }
            //通知适配器，数据发生变化，重新加载
            adapter.notifyDataSetChanged();

        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            if (cursor != null) {
                cursor.close();
            }
        }

    }
}
```


## 自定义内容提供器
> 内容提供器本质上是提供了 外界程序访问本程序中数据的一个接口。内容提供器可以决定 提供哪些表数据供访问，可以决定哪些表能被操作
>
1.
